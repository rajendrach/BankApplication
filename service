package com.wellsfargo.cbtrest.service;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.sql.Timestamp;import java.text.ParseException;import java.util.Arrays;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import org.apache.commons.lang3.StringUtils;import org.codehaus.jackson.JsonParseException;import org.codehaus.jackson.JsonParser;import org.codehaus.jackson.Version;import org.codehaus.jackson.map.JsonMappingException;import org.codehaus.jackson.map.ObjectMapper;import org.codehaus.jackson.map.SerializationConfig;import org.codehaus.jackson.map.deser.std.CalendarDeserializer;import org.codehaus.jackson.map.deser.std.TimestampDeserializer;import org.codehaus.jackson.map.module.SimpleModule;import org.json.JSONObject;import com.wellsfargo.cbtrest.model.CBTRequest;import com.wellsfargo.cbtrest.model.CBTResponse;import com.wellsfargo.cbtrest.model.Fault;import com.wellsfargo.cbtrest.utils.CBTException;import com.wellsfargo.cbtrest.utils.CBTRestUtils;import com.wellsfargo.cbtrest.utils.CustomDateDeserializer;public class CBTService { private ObjectMapper mapper = new ObjectMapper(); public CBTService() {  SimpleModule module = new SimpleModule("", Version.unknownVersion());  module.addDeserializer(Date.class, new CustomDateDeserializer());  // module.addDeserializer(Date.class, new DateDeserializer());  module.addDeserializer(Calendar.class, new CalendarDeserializer());  module.addDeserializer(Timestamp.class, new TimestampDeserializer());  mapper.registerModule(module);  mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);  mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS,    false); } public CBTResponse processCBTRequest(CBTRequest request) {  CBTResponse response = new CBTResponse();  Fault fault = new Fault();  // Auto populate the context directly from the request as it is going to  // remain the same  if (null != request.getContext()) {   response.setContext(request.getContext());  }  // Get the component name or the fully qualified package name  if (StringUtils.isNotEmpty(request.getComponent())) {   String component = request.getComponent();   try {    Class<?> cls = Class.forName(component);    Object obj = cls.newInstance();    // Get the method name in the component to be invoked    if (StringUtils.isNotEmpty(request.getFunction())) {     String function = request.getFunction();     ObjectMapper mapperObj = new ObjectMapper();     Object componentResponse = null;     // call the method     Method method = null;     Method[] methods = cls.getDeclaredMethods();     Map<String, Object> argumentParamCheckAndArgumentsMap = new HashMap<String, Object>();     for (Method methodFromLoop : methods) {      if (methodFromLoop.getName().equals(function)) {       // TODO: It might fail for overriden methods       method = methodFromLoop;       argumentParamCheckAndArgumentsMap = paramAndArgumentCheckAndArgumentArray(         method, request);       if ((Boolean) argumentParamCheckAndArgumentsMap         .get("argumentAndParamMatch")) {        break;       }      }     }     if (method != null) {      if (Modifier.isPrivate(method.getModifiers())) {       method.setAccessible(true);      }      // Check if request contains arguments      if (checkIfRequestHasArguments(request)        && (Boolean) argumentParamCheckAndArgumentsMap          .get("argumentAndParamMatch")) {       componentResponse = method         .invoke(obj,           (Object[]) argumentParamCheckAndArgumentsMap             .get("argumentArray"));      } else {       componentResponse = method.invoke(obj);      }     } else {      fault.setException("Function not found");      fault.setDetails("Function (" + function        + ") not found in component (" + component        + "). Verify function parameters/Arguments");     }     if (componentResponse != null) {      StringBuilder returnValue = new StringBuilder();      returnValue.append(mapperObj        .writeValueAsString(componentResponse));      response.setValue(returnValue.toString());     }    } else {     fault.setException("Invalid Request Data");     fault.setDetails("Function Parameter cant be empty or null");    }   } catch (Exception e) {    fault.setException(e.getCause() + " : " + e.getMessage());    fault.setDetails(CBTRestUtils.getAsStringFromStackTrace(e));   }   response.setFault(fault);  } else {   fault.setException("Invalid Request Data");   fault.setDetails("Component Parameter cant be empty or null");  }  return response; } // Util method to check if request has Arguments private boolean checkIfRequestHasArguments(CBTRequest request) {  boolean hasInputArguments = false;  // Get the Arguments  if (null != request.getArguments()) {   if (null != request.getArguments().getArgument()     && request.getArguments().getArgument().length > 0) {    hasInputArguments = true;   }  }  return hasInputArguments; } // Util method to check if this method param and request argument // match private Map<String, Object> paramAndArgumentCheckAndArgumentArray(   Method method, CBTRequest request) {  int paramCount = method.getParameterTypes().length;  int argumentCount = checkIfRequestHasArguments(request) ? request    .getArguments().getArgument().length : 0;  Map<String, Object> argumentCountAndValue = new HashMap<String, Object>();  // if (checkIfRequestHasArguments(request)) {  if (paramCount == argumentCount) {   Object[] arguments = new Object[argumentCount];   for (int i = 0; i < argumentCount; i++) {    Class<?> argumentClass = request.getArguments().getArgument()[i]      .getClass();    Class<?> parameterClass = method.getParameterTypes()[i];    boolean isArgumentAComplexObject = argumentClass.getName()      .equals("java.util.LinkedHashMap");    boolean isArgumentADateOrCalendarObject = (parameterClass      .getName().equals("java.util.Date") || (parameterClass      .getName().equals("java.util.Calendar")))      && (argumentClass.getName().equals("java.lang.String"));    boolean isArgumentExactMatchWithCurrentParam = false;    // Complex Object could be LinkedHashMap or Date or Calendar or    // Timestamp    Map<String, Object> complexObject = new HashMap<String, Object>();    boolean isPrimitive = (null != primitiveMap.get(parameterClass      .getName()) && primitiveMap.get(      parameterClass.getName()).equals(argumentClass));    if (isArgumentAComplexObject || isArgumentADateOrCalendarObject) {     if (isArgumentAComplexObject) {      complexObject = convertJsonStringToObject(        ((LinkedHashMap<?, ?>) request.getArguments()          .getArgument()[i]), null,        parameterClass.getName());     }     if (isArgumentADateOrCalendarObject) {      complexObject = convertJsonStringToObject(null, request        .getArguments().getArgument()[i].toString(),        parameterClass.getName());     }     isArgumentExactMatchWithCurrentParam = (Boolean) complexObject       .get("status");     arguments[i] = complexObject.get("value");    } else if (isPrimitive) {     arguments[i] = valueOf(argumentClass, request       .getArguments().getArgument()[i].toString());    } else {     arguments[i] = request.getArguments().getArgument()[i];    }    if (!(parameterClass.getName().equals(argumentClass.getName())) // Check                    // for                    // non                    // primitive                    // types      && !(isPrimitive)// Check for primitive types      && !(isArgumentAComplexObject && isArgumentExactMatchWithCurrentParam)      && !(isArgumentADateOrCalendarObject)) // Check                // for                // complex                // types    {     argumentCountAndValue.put("argumentAndParamMatch", false);     return argumentCountAndValue;    }   }   argumentCountAndValue.put("argumentAndParamMatch", true);   argumentCountAndValue.put("argumentArray", arguments);  } else {   argumentCountAndValue.put("argumentAndParamMatch", false);  }  return argumentCountAndValue; } @SuppressWarnings("rawtypes") private Map<String, Class> primitiveMap = new HashMap<String, Class>(); {  primitiveMap.put("int", Integer.class);  primitiveMap.put("long", Long.class);  primitiveMap.put("double", Double.class);  primitiveMap.put("float", Float.class);  primitiveMap.put("bool", Boolean.class);  primitiveMap.put("char", Character.class);  primitiveMap.put("byte", Byte.class);  primitiveMap.put("void", Void.class);  primitiveMap.put("short", Short.class); } private Map<String, Object> convertJsonStringToObject(   LinkedHashMap<?, ?> complexJson, String dateOrCalendarString,   String fullyQualifiedName) {  Map<String, Object> returnValue = new HashMap<String, Object>();  JSONObject complexJsonObj = null;  try {   complexJsonObj = new JSONObject(complexJson);  } catch (Exception e) {   // Do nothing  }  Class<?> cls;  try {   cls = Class.forName(fullyQualifiedName);   if (null != complexJsonObj && null!=complexJson) {    Object map = mapper.readValue(complexJsonObj.toString(), cls);    if(null!=map){    returnValue.put("value", cls.cast(map));    }else{     throw new CBTException(complexJsonObj.toString()+ " - Contains Unparseable date within supported formats: "       + Arrays.toString(CBTRestUtils.DATE_FORMATS));    }   } else {    returnValue.put("value", cls.cast(CBTRestUtils      .parseStringAsDate(dateOrCalendarString)));   }   returnValue.put("status", true);  } catch (JsonParseException e) {   e.printStackTrace();   returnValue.put("status", false);  } catch (JsonMappingException e) {   e.printStackTrace();   returnValue.put("status", false);  } catch (IOException e) {   e.printStackTrace();   returnValue.put("status", false);  } catch (ClassNotFoundException e1) {   e1.printStackTrace();   returnValue.put("status", false);  } catch (CBTException e) {   e.printStackTrace();   returnValue.put("status", false);  }  return returnValue; } private <T> T valueOf(Class<T> klazz, String arg) {  Exception cause = null;  T ret = null;  try {   ret = klazz.cast(klazz.getDeclaredMethod("valueOf", String.class)     .invoke(null, arg));  } catch (NoSuchMethodException e) {   cause = e;  } catch (IllegalAccessException e) {   cause = e;  } catch (InvocationTargetException e) {   cause = e;  }  if (cause == null) {   return ret;  } else {   throw new IllegalArgumentException(cause);  } }}
